import{a as T,s as S,u as x,b as M}from"./proxy-DlcL3cBf.js";import{r as h}from"./index-_un88V-Y.js";function O(t){t.values.forEach(e=>e.stop())}function A(t,e){[...e].reverse().forEach(s=>{const i=t.getVariant(s);i&&S(t,i),t.variantChildren&&t.variantChildren.forEach(o=>{A(o,e)})})}function _(t,e){if(Array.isArray(e))return A(t,e);if(typeof e=="string")return A(t,[e]);S(t,e)}function B(){const t=new Set,e={subscribe(r){return t.add(r),()=>void t.delete(r)},start(r,s){const i=[];return t.forEach(o=>{i.push(T(o,r,{transitionOverride:s}))}),Promise.all(i)},set(r){return t.forEach(s=>{_(s,r)})},stop(){t.forEach(r=>{O(r)})},mount(){return()=>{e.stop()}}};return e}function L(){const t=x(B);return M(t.mount,[]),t}const F=L;var m=new Map,g=new WeakMap,I=0,$=void 0;function j(t){return t?(g.has(t)||(I+=1,g.set(t,I.toString())),g.get(t)):"0"}function z(t){return Object.keys(t).sort().filter(e=>t[e]!==void 0).map(e=>`${e}_${e==="root"?j(t.root):t[e]}`).toString()}function P(t){const e=z(t);let r=m.get(e);if(!r){const s=new Map;let i;const o=new IntersectionObserver(u=>{u.forEach(n=>{var a;const v=n.isIntersecting&&i.some(f=>n.intersectionRatio>=f);t.trackVisibility&&typeof n.isVisible>"u"&&(n.isVisible=v),(a=s.get(n.target))==null||a.forEach(f=>{f(v,n)})})},t);i=o.thresholds||(Array.isArray(t.threshold)?t.threshold:[t.threshold||0]),r={id:e,observer:o,elements:s},m.set(e,r)}return r}function W(t,e,r={},s=$){if(typeof window.IntersectionObserver>"u"&&s!==void 0){const a=t.getBoundingClientRect();return e(s,{isIntersecting:s,target:t,intersectionRatio:typeof r.threshold=="number"?r.threshold:0,time:0,boundingClientRect:a,intersectionRect:a,rootBounds:a}),()=>{}}const{id:i,observer:o,elements:u}=P(r),n=u.get(t)||[];return u.has(t)||u.set(t,n),n.push(e),o.observe(t),function(){n.splice(n.indexOf(e),1),n.length===0&&(u.delete(t),o.unobserve(t)),u.size===0&&(o.disconnect(),m.delete(i))}}function G({threshold:t,delay:e,trackVisibility:r,rootMargin:s,root:i,triggerOnce:o,skip:u,initialInView:n,fallbackInView:a,onChange:v}={}){var f;const[b,C]=h.useState(null),l=h.useRef(v),[p,w]=h.useState({inView:!!n,entry:void 0});l.current=v,h.useEffect(()=>{if(u||!b)return;let d;return d=W(b,(E,y)=>{w({inView:E,entry:y}),l.current&&l.current(E,y),y.isIntersecting&&o&&d&&(d(),d=void 0)},{root:i,rootMargin:s,threshold:t,trackVisibility:r,delay:e},a),()=>{d&&d()}},[Array.isArray(t)?t.toString():t,b,i,s,o,u,r,a,e]);const R=(f=p.entry)==null?void 0:f.target,V=h.useRef(void 0);!b&&R&&!o&&!u&&V.current!==R&&(V.current=R,w({inView:!!n,entry:void 0}));const c=[C,p.inView,p.entry];return c.ref=c[0],c.inView=c[1],c.entry=c[2],c}export{G as a,F as u};
